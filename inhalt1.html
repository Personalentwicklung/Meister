<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIKP - Personalentwicklung</title>
    <style>
        /* Allgemeine Einstellungen für den Body (direkt aus ZIP-13.html übernommen) */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 40px 20px; /* Einheitlicher Padding wie in ZIP-13 */
            background-color: #f0f2f5; /* Hintergrundfarbe wie in ZIP-13 */
            color: #333;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Startpunkt des Containers anpassen */
            min-height: 100vh;
            box-sizing: border-box; /* Wichtig für konsistentes Box-Modell */
        }

        /* Container für den gesamten Test, um ihn zu zentrieren und zu stylen (direkt aus ZIP-13.html übernommen) */
        .container {
            background-color: #ffffff;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1); /* Schatten wie in ZIP-13 */
            max-width: 900px;
            width: 100%;
            box-sizing: border-box; /* Wichtig für konsistentes Box-Modell */
        }

        h1 {
            color: #1a4e8a;
            text-align: center;
            font-size: 2.2em;
            margin-bottom: 5px; /* Abstand zu h2 */
        }

        h2 {
            color: #0b3d91;
            text-align: center;
            font-size: 1.5em;
            margin-top: 0; /* Abstand zu h1 */
            margin-bottom: 30px; /* Abstand zum Inhalt */
        }

        .question-navigation-bar {
            text-align: center;
            margin-bottom: 20px;
            padding: 10px 0;
            border-bottom: 1px solid #e0e0e0;
        }

        .question-navigation-bar button {
            background-color: #e9ecef;
            color: #495057;
            border: 1px solid #ced4da;
            padding: 8px 15px;
            margin: 0 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.2s, border-color 0.2s;
        }

        .question-navigation-bar button:hover {
            background-color: #dee2e6;
        }

        .question-navigation-bar button.active {
            background-color: #0b3d91;
            color: white;
            border-color: #0b3d91;
        }

        .question-section {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .question-title {
            font-size: 1.3em;
            color: #1a4e8a;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .question-text {
            font-size: 1.1em;
            color: #343a40;
            margin-bottom: 20px;
            line-height: 1.6;
        }

        textarea.user-answer {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            font-family: inherit;
            font-size: 1em;
            min-height: 120px;
            box-sizing: border-box; /* Wichtig für korrekte Breite */
            margin-bottom: 15px;
            resize: vertical;
        }

        .btn-check-answer, .btn-toggle-musterloesung {
            background-color: #0b3d91;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s;
            display: inline-block;
            margin-right: 10px;
        }

        .btn-check-answer:hover, .btn-toggle-musterloesung:hover {
            background-color: #082d6b;
        }

        .btn-check-answer.recheck-button {
            background-color: #6c757d; /* Grau für erneutes Prüfen */
        }

        .btn-check-answer.recheck-button:hover {
            background-color: #5a6268;
        }

        .recheck-info-text {
            font-size: 0.85em;
            color: #6c757d;
            margin-top: 10px;
            display: none; /* Standardmäßig ausgeblendet */
        }

        .feedback-section {
            background-color: #e9f7ef;
            border: 1px solid #d4edda;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            display: none; /* Standardmäßig ausgeblendet */
        }

        .feedback-section h3 {
            color: #1a4e8a;
            margin-top: 0;
            font-size: 1.2em;
            margin-bottom: 15px;
        }

        .feedback-item {
            display: flex;
            align-items: flex-start;
            margin-bottom: 10px;
            font-size: 0.95em;
        }

        .feedback-icon {
            margin-right: 10px;
            font-size: 1.2em;
            line-height: 1.5; /* Align icon with text */
        }

        .feedback-item.ok { color: #28a745; } /* Grün */
        .feedback-item.hinweis { color: #ffc107; } /* Gelb */
        .feedback-item.error { color: #dc3545; } /* Rot */

        .score {
            font-size: 1.4em;
            font-weight: bold;
            color: #1a4e8a;
            text-align: right;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px dashed #ced4da;
        }

        .correct-answer-content-container {
            background-color: #f0f8ff;
            border: 1px dashed #aed9ed;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            display: none; /* Standardmäßig ausgeblendet */
        }

        .correct-answer-content-container h3 {
            color: #0b3d91;
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .correct-answer-content p {
            margin-bottom: 10px;
            line-height: 1.6;
        }
        .correct-answer-content strong {
            color: #0b3d91;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>MIKP - Prüfungsvorbereitung</h1>
        <h2 id="thema-sub-titel">Personalentwicklung</h2>

        <div id="questionNavigationBar" class="question-navigation-bar">
            </div>

        <div id="questionSectionContainer">
            </div>

        <template id="questionTemplate">
            <div class="question-section">
                <div class="question-title"></div>
                <div class="question-text"></div>
                <textarea class="user-answer" placeholder="Geben Sie hier Ihre Antwort ein..."></textarea>
                <button class="btn-check-answer">Antwort überprüfen</button>
                <button class="btn-toggle-musterloesung">Musterlösung anzeigen</button>
                <div class="recheck-info-text">Antwort wurde geändert. Bitte erneut prüfen.</div>

                <div class="feedback-section">
                    <h3>Feedback zu Ihrer Antwort:</h3>
                    <div class="feedback-details">
                        </div>
                    <div class="score"></div>
                </div>

                <div class="correct-answer-content-container">
                    <h3>Musterlösung:</h3>
                    <div class="correct-answer-content">
                        </div>
                </div>
            </div>
        </template>
    </div>

    <script>
        let questions = [];
        let currentQuestionIndex = 0;
        const defaultThemaId = "pe-prozess"; // Festgelegte ThemaID

        // NEU: Die Fragen-Daten sind hier direkt in der HTML-Datei eingebettet.
        // Keine separate fragen_pe-prozess.json-Datei mehr notwendig!
        const allQuestionData = [
  {
    "id": "pep1",
    "themaID": "pe-prozess",
    "frageNummer": 1,
    "titel": "Frage 1:",
    "frageText": "Beschreiben Sie die fünf Phasen des Personalentwicklungsprozesses und erläutern Sie deren Bedeutung für die betriebliche Praxis.",
    "commonFeedback": {
      "positiv": "Sehr gut! Dieser Aspekt wurde umfassend erkannt.",
      "neutral": "Dieser Begriff wurde erkannt, die Beschreibung könnte ausführlicher sein.",
      "negativ": "Dieser Begriff wurde nicht erwähnt."
    },
    "musterloesung": "Der Personalentwicklungsprozess gliedert sich in fünf aufeinanderfolgende Phasen:\n\n**Bedarfsanalyse:** Hier wird ermittelt, welche Qualifikationen im Unternehmen fehlen oder künftig benötigt werden. Dies geschieht durch Methoden wie Befragungen, Beobachtungen oder Dokumentenanalysen.\n\n**Zielplanung:** In dieser Phase werden konkrete Entwicklungsziele definiert, die sowohl auf individuelle als auch auf unternehmerische Anforderungen abgestimmt sind.\n\n**Maßnahmengestaltung:** Es werden geeignete Entwicklungsmaßnahmen ausgewählt, die sowohl pädagogisch sinnvoll als auch wirtschaftlich tragfähig sind.\n\n**Durchführung:** Die geplanten Maßnahmen werden umgesetzt – z. B. durch Schulungen, Coaching oder Training-on-the-Job.\n\n**Erfolgskontrolle:** Abschließend wird überprüft, ob die Maßnahmen die gewünschten Effekte erzielt haben. Dies kann durch Feedback, Tests oder Leistungsbeurteilungen erfolgen.\n\nDer strukturierte Ablauf stellt sicher, dass Personalentwicklungsmaßnahmen zielgerichtet und effektiv sind, die Mitarbeiterkompetenzen systematisch aufbauen und langfristig zum Unternehmenserfolg beitragen."
  },
  {
    "id": "pep2",
    "themaID": "pe-prozess",
    "frageNummer": 2,
    "titel": "Frage 2:",
    "frageText": "Warum ist Personalentwicklung in Zeiten von Fachkräftemangel und technologischem Wandel von strategischer Bedeutung für Unternehmen? Nennen Sie mindestens drei Gründe.",
    "commonFeedback": {
      "positiv": "Sehr gut! Dieser Aspekt wurde umfassend erkannt.",
      "neutral": "Dieser Begriff wurde erkannt, die Beschreibung könnte ausführlicher sein.",
      "negativ": "Dieser Begriff wurde nicht erwähnt."
    },
    "musterloesung": "Personalentwicklung (PE) ist aus mehreren Gründen strategisch bedeutsam:\n\n**Sicherung von Fachkräften und Know-how:** In Zeiten des Fachkräftemangels hilft PE, qualifizierte Mitarbeiter zu binden und neue Talente zu entwickeln. Sie sichert das interne Know-how und reduziert die Abhängigkeit vom externen Arbeitsmarkt.\n\n**Anpassung an technologischen Wandel:** Neue Technologien erfordern ständige Weiterbildung. PE stellt sicher, dass die Belegschaft mit den erforderlichen digitalen Kompetenzen ausgestattet ist und sich an veränderte Arbeitswelten anpassen kann.\n\n**Steigerung von Motivation und Mitarbeiterbindung:** Gezielte Entwicklungsmaßnahmen zeigen Mitarbeitern Wertschätzung, fördern ihre Karrierechancen und erhöhen ihre Zufriedenheit und Loyalität gegenüber dem Unternehmen.\n\n**Förderung von Innovation und Wettbewerbsfähigkeit:** Eine gut ausgebildete und motivierte Belegschaft ist innovationsfähiger. PE unterstützt die Entwicklung neuer Ideen und Prozesse, was die Wettbewerbsfähigkeit des Unternehmens stärkt.\n\n**Nachfolgeplanung:** PE identifiziert und entwickelt potenzielle Führungskräfte und Schlüsselpositionen im Unternehmen, um einen reibungslosen Übergang bei Austritten oder Beförderungen zu gewährleisten."
  }
];


        // Stark verbesserter Stemmer für Deutsch (für robustere Anwendung)
        function simpleStemmer(word) {
            word = word.toLowerCase();
            // Entfernen von Satzzeichen und spezifischen Sonderzeichen
            word = word.replace(/[.,!?;:()"\-]/g, '');
            // 1. Spezifische Suffixe für Nomen/Adjektive, länger zuerst
            if (word.endsWith('schaften')) return word.slice(0, -7); // Gemeinschaft -> Gemein
            if (word.endsWith('lichkeiten')) return word.slice(0, -10); // Möglichkeiten -> Möglich
            if (word.endsWith('erungen')) return word.slice(0, -7); // Bewertungen -> Bewert
            if (word.endsWith('itäten')) return word.slice(0, -5); // Qualitäten -> Qualit
            if (word.endsWith('ition')) return word.slice(0, -4); // Motivation, Innovation -> Motiv, Innov
            if (word.endsWith('ierung')) return word.slice(0, -6); // Steigerung -> Steiger
            if (word.endsWith('bindung')) return word.slice(0, -7); // Mitarbeiterbindung -> Mitarbeiter
            if (word.endsWith('kompetenzen')) return word.slice(0, -11) + 'enz'; // Kompetenzen -> Kompetenz
            if (word.endsWith('kraft')) return word.slice(0, -5); // Innovationskraft -> Innovation
            // 2. Allgemeine Nomen-/Adjektiv-Endungen und Plurale
            if (word.endsWith('ung')) return word.slice(0, -3); // Achtung: muss nach "ierungen" kommen
            if (word.endsWith('keit')) return word.slice(0, -4); // Möglichkeit -> Möglich
            if (word.endsWith('haft')) return word.slice(0, -4); // lebhaft -> leb
            if (word.endsWith('lich')) return word.slice(0, -4); // persönlich -> persönlich
            if (word.endsWith('bar')) return word.slice(0, -3); // sichtbar -> sicht
            if (word.endsWith('isch')) return word.slice(0, -4); // praktisch -> prakt
            if (word.endsWith('en')) return word.slice(0, -2); // Gedanken -> Gedank
            if (word.endsWith('er')) return word.slice(0, -2); // besser -> bess
            if (word.endsWith('es')) return word.slice(0, -2); // neues -> neu
            if (word.endsWith('s')) return word.slice(0, -1); // Wandelns -> Wandel
            // 3. Verb-Endungen (oft nach Endungen wie '-ieren', '-t')
            if (word.endsWith('iert')) return word.slice(0, -3); // motiviert -> motiv
            if (word.endsWith('tet')) return word.slice(0, -3); // arbeitet -> arbeit
            if (word.endsWith('t')) { // allgemeines 't' am Ende, nach spezifischeren Regeln
                // Sicherstellen, dass nicht zu aggressive Kürzung stattfindet (z.B. 'ist' bleibt 'is')
                if (word.length > 3) return word.slice(0, -1);
            }
            if (word.endsWith('n') && word.length > 2 && !['a', 'e', 'i', 'o', 'u'].includes(word.charAt(word.length - 2))) {
                return word.slice(0, -1); // finden -> find (nur wenn Konsonant vor 'n')
            }
            if (word.endsWith('e') && word.length > 2) {
                // Nur 'e' entfernen, wenn es keine Wurzel bildet (z.B. 'frage' bleibt 'frag')
                return word.slice(0, -1);
            }
                        return word;
        }

        async function loadQuestions() {
            try {
                // Fragen aus dem direkt eingebetteten Array laden
                questions = allQuestionData.filter(q => q.themaID === defaultThemaId);
                // Fragen nach frageNummer sortieren, um die korrekte Reihenfolge zu gewährleisten
                questions.sort((a, b) => a.frageNummer - b.frageNummer);

                if (questions.length === 0) {
                    document.getElementById('questionSectionContainer').innerHTML = '<p>Keine Fragen für dieses Thema gefunden.</p>';
                    return;
                }
                renderNavigationBar();
                zeigeFrage(0); // Zeigt die erste Frage beim Start
            } catch (error) {
                // Dieser Block sollte normalerweise nicht erreicht werden, da keine Datei geladen wird.
                console.error("Fehler beim Laden der Fragen (intern):", error);
                document.getElementById('questionSectionContainer').innerHTML = `<p>Ein interner Fehler ist aufgetreten: ${error.message}. Bitte überprüfen Sie die Konsolenmeldung.</p>`;
            }
        }

        function renderNavigationBar() {
            const navBar = document.getElementById('questionNavigationBar');
            navBar.innerHTML = '';
            questions.forEach((q, index) => {
                const button = document.createElement('button');
                button.textContent = `Frage ${q.frageNummer}`; // Nutze frageNummer für den Button-Text
                button.onclick = () => zeigeFrage(index);
                if (index === currentQuestionIndex) {
                    button.classList.add('active');
                }
                navBar.appendChild(button);
            });
        }

        function zeigeFrage(index) {
            if (index < 0 || index >= questions.length) return;
            currentQuestionIndex = index;
            const question = questions[currentQuestionIndex];
            const container = document.getElementById('questionSectionContainer');
            const template = document.getElementById('questionTemplate');
            const clone = document.importNode(template.content, true);

            clone.querySelector('.question-title').textContent = question.titel;
            clone.querySelector('.question-text').textContent = question.frageText;
            const answerInput = clone.querySelector('.user-answer');
            const checkAnswerButton = clone.querySelector('.btn-check-answer');
            const toggleSolutionButton = clone.querySelector('.btn-toggle-musterloesung');
            const feedbackSection = clone.querySelector('.feedback-section');
            const solutionContainer = clone.querySelector('.correct-answer-content-container');
            const recheckInfoText = clone.querySelector('.recheck-info-text');

            // Setzt den Zustand der Buttons und Textfelder zurück
            answerInput.value = question.userAnswer || ''; // Lädt gespeicherte Antwort
            checkAnswerButton.textContent = 'Antwort überprüfen';
            checkAnswerButton.classList.remove('recheck-button');
            toggleSolutionButton.style.display = 'none'; // Musterlösungsbutton verstecken
            feedbackSection.style.display = 'none';      // Feedback-Sektion verstecken
            solutionContainer.style.display = 'none';     // Musterlösung-Container verstecken
            recheckInfoText.style.display = 'none';       // Dynamischen Text beim Fragenwechsel ausblenden

            checkAnswerButton.onclick = () => evaluateAnswer(question, answerInput, checkAnswerButton, toggleSolutionButton, feedbackSection, solutionContainer, recheckInfoText);
            toggleSolutionButton.onclick = () => toggleMusterloesung(question, toggleSolutionButton, solutionContainer);

            container.innerHTML = ''; // Vorherige Frage entfernen
            container.appendChild(clone);
            renderNavigationBar(); // Aktualisiert den aktiven Button in der Navigation
        }

        function evaluateAnswer(question, answerInput, checkAnswerButton, toggleSolutionButton, feedbackSection, solutionContainer, recheckInfoText) {
            const userAnswer = answerInput.value;
            // Speichern der Benutzerantwort
            question.userAnswer = userAnswer;

            // Prepare the user answer: lowercase, remove punctuation, then stem each word
            const stemmedUserAnswerWords = userAnswer.split(/\s+/)
                                                .map(word => simpleStemmer(word))
                                                .filter(word => word.length > 0);
                        
            // Reconstruct stemmedUserAnswerText for includes() check on phrases (which might span multiple stemmed words)
            const stemmedUserAnswerText = stemmedUserAnswerWords.join(' ');

            let totalPoints = 0;
            const maxPointsPerCriterion = 2; // ✅ = 2 Punkte, ⚠️ = 1 Punkt, ❌ = 0 Punkte
            let totalPossibleScore = question.bewertungskriterien.length * maxPointsPerCriterion;

            const feedbackDetails = feedbackSection.querySelector('.feedback-details');
            feedbackDetails.innerHTML = ''; // Vorheriges Feedback löschen

            const commonFeedback = question.commonFeedback; // Zugriff auf das ausgelagerte Feedback

            question.bewertungskriterien.forEach(criterion => {
                let points = 0;
                let feedbackText = '';
                let matchedType = 'none'; // 'phrase', 'single', 'none'

                // Priorität 1: Phrasen prüfen (2 Punkte)
                if (criterion.phrases && Array.isArray(criterion.phrases)) {
                    // Sortieren der Phrasen nach Länge absteigend, um längere/spezifischere Treffer zu bevorzugen
                    const sortedPhrases = criterion.phrases
                        .map(ph => simpleStemmer(ph))
                        .sort((a, b) => b.length - a.length);
                    for (const stemmedPhrase of sortedPhrases) {
                        if (stemmedUserAnswerText.includes(stemmedPhrase)) {
                            matchedType = 'phrase';
                            break; // Phrase gefunden, direkt 2 Punkte vergeben
                        }
                    }
                }

                // Priorität 2: Keywords prüfen (1 Punkt), NUR wenn noch keine Phrase gefunden wurde
                if (matchedType === 'none' && criterion.keywords && Array.isArray(criterion.keywords)) {
                    const stemmedKeywords = criterion.keywords.map(kw => simpleStemmer(kw));
                    for (const stemmedKeyword of stemmedKeywords) {
                        if (stemmedUserAnswerText.includes(stemmedKeyword)) {
                            matchedType = 'single';
                            break; // Keyword gefunden, 1 Punkt vergeben
                        }
                    }
                }
                                
                // Punkte und Feedback-Text basierend auf matchedType und commonFeedback festlegen
                if (matchedType === 'phrase') {
                    points = maxPointsPerCriterion; // 2 Punkte für Phrasentreffer
                    feedbackText = commonFeedback.positiv;
                } else if (matchedType === 'single') {
                    points = 1; // 1 Punkt für Einzelworttreffer
                    feedbackText = commonFeedback.neutral;
                } else {
                    points = 0; // Nichts gefunden
                    feedbackText = commonFeedback.negativ;
                }
                totalPoints += points;

                const feedbackItem = document.createElement('div');
                feedbackItem.classList.add('feedback-item');
                let icon = ''; // Icon wird hier im HTML generiert
                let feedbackClass = '';
                if (points === 2) {
                    icon = '✅';
                    feedbackClass = 'ok';
                } else if (points === 1) {
                    icon = '⚠️';
                    feedbackClass = 'hinweis';
                } else {
                    icon = '❌';
                    feedbackClass = 'error';
                }
                feedbackItem.classList.add(feedbackClass);

                // HTML-Struktur fügt Icon und Bolding des Kriteriumsnamens hinzu. feedbackText ist nur der reine Text aus JSON.
                feedbackItem.innerHTML = `<span class="feedback-icon">${icon}</span> <span><strong>${criterion.name}:</strong> ${feedbackText}</span>`;
                feedbackDetails.appendChild(feedbackItem);
            });

            const percentage = (totalPossibleScore > 0) ? (totalPoints / totalPossibleScore) * 100 : 0;
            const scoreDisplay = feedbackSection.querySelector('.score');
            scoreDisplay.textContent = `Ergebnis in Prozent: ${percentage.toFixed(0)}%`;
                        
            feedbackSection.style.display = 'block';
            toggleSolutionButton.style.display = 'block'; // Musterlösungsbutton anzeigen

            // Button-Text und -Farbe ändern
            checkAnswerButton.textContent = 'Antwort erneut prüfen';
            checkAnswerButton.classList.add('recheck-button');

            // Dynamischen Text anzeigen
            recheckInfoText.style.display = 'block';
        }

        function toggleMusterloesung(question, button, solutionContainer) {
            if (solutionContainer.style.display === 'block') {
                solutionContainer.style.display = 'none';
                button.textContent = 'Musterlösung anzeigen';
            } else {
                // Ersetze **Text** durch <strong>Text</strong>
                let formattedSolution = question.musterloesung.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                                
                // Teile den Text an doppelten Zeilenumbrüchen in Absätze auf
                const paragraphs = formattedSolution.split(/\n\s*\n/).filter(p => p.trim() !== '');
                let htmlContent = '';
                paragraphs.forEach(p => {
                    // Ersetze einzelne Zeilenumbrüche innerhalb eines Absatzes durch <br>
                    htmlContent += `<p>${p.replace(/\n/g, '<br>')}</p>`;
                });

                solutionContainer.querySelector('.correct-answer-content').innerHTML = htmlContent;
                solutionContainer.style.display = 'block';
                button.textContent = 'Musterlösung ausblenden';
            }
        }

        // Start der Anwendung
        document.addEventListener('DOMContentLoaded', loadQuestions);
    </script>
</body>
</html>
