<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MIKP - Personalentwicklung</title>
  <style>
    /* Allgemeine Einstellungen für den Body */
    body {
      font-family: Arial, sans-serif;
      margin: 2rem;
      background-color: #f9f9f9;
      color: #333;
    }
    /* Container for the main content to center and style */
    .container {
      background-color: #ffffff;
      padding: 30px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      max-width: 800px;
      margin: 20px auto;
      box-sizing: border-box;
    }
    h1 {
      color: #0a3069;
      text-align: left;
      font-size: 1.8em;
      margin-bottom: 20px;
    }
    p {
      line-height: 1.6;
      margin-bottom: 10px;
    }
    textarea {
      width: 100%;
      height: 150px;
      font-size: 16px;
      padding: 10px;
      margin-top: 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-sizing: border-box;
    }
    .button {
      padding: 10px 20px;
      font-size: 16px;
      background-color: #007BFF;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 15px;
      transition: background-color 0.2s ease;
    }
    .button:hover {
      background-color: #0056b3;
    }
    .feedback-section {
      margin-top: 20px;
      padding: 15px;
      background-color: #eef4ff;
      border-left: 5px solid #007BFF;
      border-radius: 4px;
      display: none; /* Hidden by default */
    }
    .feedback-section h3 {
      color: #0a3069;
      margin-top: 0;
      margin-bottom: 10px;
    }
    .feedback-section ul {
      list-style: none;
      padding: 0;
    }
    .feedback-section li {
      margin-bottom: 8px;
      font-size: 15px;
      line-height: 1.4;
    }
    .feedback-ok { color: green; }
    .feedback-hinweis { color: orange; }
    .feedback-fehler { color: red; }
    .musterloesung-section {
      margin-top: 20px;
      padding: 15px;
      background-color: #f0f8ff;
      border-left: 5px solid #28a745;
      border-radius: 4px;
      display: none; /* Hidden by default */
    }
    .musterloesung-section h3 {
      color: #28a745;
      margin-top: 0;
      margin-bottom: 10px;
    }
  </style>
</head>
<body>

  <div class="container">
    <h1 id="mainQuestionTitle"></h1>
    <p id="mainQuestionText"></p>
    <textarea id="antwort" placeholder="Gib hier deine Antwort ein..."></textarea>
    <br>
    <button class="button" onclick="bewerteAntwort()">Antwort prüfen</button>
    <button id="showMusterloesungBtn" class="button" style="display:none;" onclick="zeigeMusterloesung()">Musterlösung anzeigen</button>

    <div id="feedbackSection" class="feedback-section"></div>
    <div id="musterloesungSection" class="musterloesung-section"></div>
  </div>

  <script src="index.js"></script> 
  <script>
    // Global variables for the current question and loaded data
    let aktuelleFrageDaten = null;
    let alleGeladeneFragen = {}; // To store all questions loaded from JSON

    // Helper for Stemming (using Snowball German)
    function stemWord(word) {
      if (typeof snowballFactory !== 'function') {
        console.error("Snowball stemmer factory not found. Make sure index.js is loaded correctly.");
        return word; // Fallback to original word
      }
      const stemmer = snowballFactory('German');
      stemmer.setCurrent(word);
      stemmer.stem();
      return stemmer.getCurrent();
    }

    // Normalization function
    function normalizeText(text) {
      return text.toLowerCase()
                 .replace(/ä/g, 'ae')
                 .replace(/ö/g, 'oe')
                 .replace(/ü/g, 'ue')
                 .replace(/ß/g, 'ss')
                 .replace(/[^a-z0-9\s]/g, ' ')
                 .trim();
    }

    // Main evaluation function
    async function bewerteAntwort() {
      if (!aktuelleFrageDaten) {
        console.error("Keine Frage geladen.");
        return;
      }

      const antwortText = document.getElementById("antwort").value;
      const normalisierteAntwort = normalizeText(antwortText);
      // Split by one or more spaces, filter out empty strings
      const gestemmteAntwortWoerter = normalisierteAntwort.split(/\s+/).map(word => stemWord(word)).filter(word => word); 

      const feedbackSection = document.getElementById("feedbackSection");
      feedbackSection.style.display = "block";
      document.getElementById("showMusterloesungBtn").style.display = "block"; // Show Musterlösung button

      let feedbackHTML = "<h3>Feedback:</h3><ul>";
      let totalPoints = 0;
      let maxPoints = 0;

      aktuelleFrageDaten.bewertungskriterien.forEach(kriterium => {
        const gestemmteKeywords = kriterium.keywords.map(word => stemWord(normalizeText(word)));
        const kriteriumNameStemmed = stemWord(normalizeText(kriterium.name));

        let status = 'nicht_erkannt';
        let feedbackMessage = `<li class='feedback-fehler'>✘ Der Begriff "${kriterium.name}" wurde nicht genannt.</li>`;

        // Check for direct keyword match or criterion name match (stemmed)
        const keywordOrNameFound = gestemmteKeywords.some(kw => gestemmteAntwortWoerter.includes(kw)) || gestemmteAntwortWoerter.includes(kriteriumNameStemmed);
        
        if (keywordOrNameFound) {
          // Count words in the answer text (not stemmed words)
          const wordCount = antwortText.split(/\s+/).filter(word => word).length;

          // Simple heuristic: count words in the *entire* answer
          // For a more precise "sentence around keyword" count, a more advanced NLP approach would be needed.
          // For now, we compare total word count to minWoerterFuerBeschreibung.
          // This ensures that "erkannt_ausreichend_beschrieben" needs a substantial overall answer.
          // This heuristic might need further refinement based on user testing.
          
          // Alternative heuristic: Attempt to find words around the first matched keyword
          let relevantSentenceWords = 0;
          const firstMatchedKeyword = kriterium.keywords.find(kw => antwortText.toLowerCase().includes(normalizeText(kw))) || kriterium.name;
          const keywordIndex = antwortText.toLowerCase().indexOf(normalizeText(firstMatchedKeyword));

          if (keywordIndex !== -1) {
              // Extract a segment around the keyword to estimate relevant description length
              const contextStart = Math.max(0, keywordIndex - 30); // 30 chars before
              const contextEnd = Math.min(antwortText.length, keywordIndex + normalizeText(firstMatchedKeyword).length + 70); // 70 chars after
              const contextSnippet = antwortText.substring(contextStart, contextEnd);
              relevantSentenceWords = contextSnippet.split(/\s+/).filter(word => word).length;
          } else {
              // Fallback to total word count if no specific keyword context can be found
              relevantSentenceWords = wordCount;
          }


          if (relevantSentenceWords >= kriterium.minWoerterFuerBeschreibung) {
            status = 'erkannt_ausreichend_beschrieben';
            feedbackMessage = `<li class='feedback-ok'>✅ Der Begriff "${kriterium.name}" wurde ausreichend beschrieben.</li>`;
            totalPoints += 2; // Full points
          } else {
            status = 'erkannt_kurz';
            // Corrected: use only feedback_kurz directly
            feedbackMessage = `<li class='feedback-hinweis'>⚠️ ${kriterium.feedback_kurz}</li>`;
            totalPoints += 1; // Half points
          }
        }

        feedbackHTML += feedbackMessage;
        maxPoints += 2; // Each criterion is worth 2 points if fully described
      });

      feedbackHTML += `</ul><p><strong>Gesamtpunktzahl: ${totalPoints} / ${maxPoints}</strong></p>`;
      feedbackSection.innerHTML = feedbackHTML;
    }

    // Function to load questions from the JSON file
    async function ladeFragen() {
      try {
        const response = await fetch('fragen_pe-prozess.json');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        alleGeladeneFragen = await response.json();
        // Assuming we are always working with 'pep1' for now, based on the context
        aktuelleFrageDaten = alleGeladeneFragen.find(q => q.id === 'pep1');

        if (aktuelleFrageDaten) {
          document.getElementById('mainQuestionTitle').textContent = aktuelleFrageDaten.titel;
          document.getElementById('mainQuestionText').innerHTML = `<strong>Frage:</strong> ${aktuelleFrageDaten.frageText}`;
          document.getElementById('musterloesungSection').innerHTML = `<h3>Musterlösung:</h3><p>${aktuelleFrageDaten.musterloesung.replace(/\n/g, '<br>')}</p>`;
        } else {
          console.error("Frage 'pep1' nicht im JSON gefunden.");
        }
      } catch (e) {
        console.error("Fehler beim Laden der Fragen aus JSON:", e);
        document.getElementById('mainQuestionTitle').textContent = "Fehler beim Laden der Frage.";
        document.getElementById('mainQuestionText').textContent = "Bitte stellen Sie sicher, dass 'fragen_pe-prozess.json' korrekt im selben Verzeichnis liegt.";
      }
    }

    // Function to show the model answer
    function zeigeMusterloesung() {
      document.getElementById("musterloesungSection").style.display = "block";
    }

    // Initialize the application when the DOM is fully loaded
    document.addEventListener('DOMContentLoaded', ladeFragen);
  </script>
</body>
</html>
